// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/pkg/errors"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for Severity.
const (
	SeverityCritical Severity = "Critical"

	SeverityHigh Severity = "High"

	SeverityLow Severity = "Low"

	SeverityMedium Severity = "Medium"

	SeverityNegligible Severity = "Negligible"

	SeverityUnknown Severity = "Unknown"
)

// Artifact defines model for Artifact.
type Artifact struct {

	// The artifact's digest, consisting of an algorithm and hex portion.
	Digest *string `json:"digest,omitempty"`

	// The MIME type of the artifact.
	MimeType *string `json:"mime_type,omitempty"`

	// The name of the Docker Registry repository containing the artifact.
	Repository *string `json:"repository,omitempty"`

	// The artifact's tag
	Tag *string `json:"tag,omitempty"`
}

// CVSSDetails defines model for CVSSDetails.
type CVSSDetails struct {

	// The CVSS 2.0 score for the vulnerability.
	ScoreV2 *float32 `json:"score_v2,omitempty"`

	// The CVSS 3.0 score for the vulnerability.
	ScoreV3 *float32 `json:"score_v3,omitempty"`

	// The CVSS 2.0 vector for the vulnerability. The string is of the form AV:L/AC:M/Au:N/C:P/I:N/A:N
	VectorV2 *string `json:"vector_v2,omitempty"`

	// The CVSS 3.0 vector for the vulnerability.
	VectorV3 *string `json:"vector_v3,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error *Error `json:"error,omitempty"`
}

// HarborVulnerabilityReport defines model for HarborVulnerabilityReport.
type HarborVulnerabilityReport struct {
	Artifact    *Artifact  `json:"artifact,omitempty"`
	GeneratedAt *time.Time `json:"generated_at,omitempty"`

	// Basic scanner properties such as name, vendor, and version.
	Scanner *Scanner `json:"scanner,omitempty"`

	// A standard scale for measuring the severity of a vulnerability.
	//
	// * `Unknown` - either a security problem that has not been assigned to a priority yet or a priority that the
	//   scanner did not recognize.
	// * `Negligible` - technically a security problem, but is only theoretical in nature, requires a very special
	//   situation, has almost no install base, or does no real damage.
	// * `Low` - a security problem, but is hard to exploit due to environment, requires a user-assisted attack,
	//   a small install base, or does very little damage.
	// * `Medium` - a real security problem, and is exploitable for many people. Includes network daemon denial of
	//   service attacks, cross-site scripting, and gaining user privileges.
	// * `High` - a real problem, exploitable for many people in a default installation. Includes serious remote denial
	//   of service, local root privilege escalations, or data loss.
	// * `Critical` - a world-burning problem, exploitable for nearly all people in a default installation. Includes
	//   remote root privilege escalations, or massive data loss.
	Severity        *Severity            `json:"severity,omitempty"`
	Vulnerabilities *[]VulnerabilityItem `json:"vulnerabilities,omitempty"`
}

// Registry defines model for Registry.
type Registry struct {

	// An optional value of the HTTP Authorization header sent with each request to the Docker Registry v2 API.
	// It's used to exchange Base64 encoded robot account credentials to a short lived JWT access token which
	// allows the underlying scanner to pull the artifact from the Docker Registry.
	Authorization *string `json:"authorization,omitempty"`

	// A base URL or the Docker Registry v2 API.
	Url *string `json:"url,omitempty"`
}

// ScanRequest defines model for ScanRequest.
type ScanRequest struct {
	Artifact Artifact `json:"artifact"`
	Registry Registry `json:"registry"`
}

// A unique identifier returned by the [/scan](#/operation/AcceptScanRequest] operations. The format of the
// identifier is not imposed but it should be unique enough to prevent collisons when polling for scan reports.
type ScanRequestId string

// ScanResponse defines model for ScanResponse.
type ScanResponse struct {

	// A unique identifier returned by the [/scan](#/operation/AcceptScanRequest] operations. The format of the
	// identifier is not imposed but it should be unique enough to prevent collisons when polling for scan reports.
	Id ScanRequestId `json:"id"`
}

// Basic scanner properties such as name, vendor, and version.
type Scanner struct {

	// The name of the scanner.
	Name *string `json:"name,omitempty"`

	// The name of the scanner's provider.
	Vendor *string `json:"vendor,omitempty"`

	// The version of the scanner.
	Version *string `json:"version,omitempty"`
}

// Represents metadata of a Scanner Adapter which allows Harbor to lookup a scanner capable
// of scanning a given Artifact stored in its registry and making sure that it
// can interpret a returned result.
type ScannerAdapterMetadata struct {
	Capabilities []ScannerCapability `json:"capabilities"`

	// A set of custom properties that can further describe capabilities of a given scanner.
	Properties *ScannerProperties `json:"properties,omitempty"`

	// Basic scanner properties such as name, vendor, and version.
	Scanner Scanner `json:"scanner"`
}

// Capability consists of the set of recognized artifact MIME types and the set of scanner report MIME types.
// For example, a scanner capable of analyzing Docker images and producing a vulnerabilities report recognizable
// by Harbor web console might be represented with the following capability:
// - consumes MIME types:
//   - `application/vnd.oci.image.manifest.v1+json`
//   - `application/vnd.docker.distribution.manifest.v2+json`
// - produces MIME types:
//   - `application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0`
type ScannerCapability struct {

	// The set of MIME types of the artifacts supported by the scanner to produce the reports specified in the "produces_mime_types". A given
	// mime type should only be present in one capability item.
	ConsumesMimeTypes []string `json:"consumes_mime_types"`

	// The set of MIME types of reports generated by the scanner for the consumes_mime_types of the same capability record.
	ProducesMimeTypes []string `json:"produces_mime_types"`
}

// A set of custom properties that can further describe capabilities of a given scanner.
type ScannerProperties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A standard scale for measuring the severity of a vulnerability.
//
// * `Unknown` - either a security problem that has not been assigned to a priority yet or a priority that the
//   scanner did not recognize.
// * `Negligible` - technically a security problem, but is only theoretical in nature, requires a very special
//   situation, has almost no install base, or does no real damage.
// * `Low` - a security problem, but is hard to exploit due to environment, requires a user-assisted attack,
//   a small install base, or does very little damage.
// * `Medium` - a real security problem, and is exploitable for many people. Includes network daemon denial of
//   service attacks, cross-site scripting, and gaining user privileges.
// * `High` - a real problem, exploitable for many people in a default installation. Includes serious remote denial
//   of service, local root privilege escalations, or data loss.
// * `Critical` - a world-burning problem, exploitable for nearly all people in a default installation. Includes
//   remote root privilege escalations, or massive data loss.
type Severity string

// VulnerabilityItem defines model for VulnerabilityItem.
type VulnerabilityItem struct {

	// The Common Weakness Enumeration Identifiers associated with this vulnerability.
	CweIds *[]string `json:"cwe_ids,omitempty"`

	// The detailed description of the vulnerability.
	Description *string `json:"description,omitempty"`

	// The version of the package containing the fix if available.
	FixVersion *string `json:"fix_version,omitempty"`

	// The unique identifier of the vulnerability.
	Id *string `json:"id,omitempty"`

	// The list of links to the upstream databases with the full description of the vulnerability.
	Links *[]string `json:"links,omitempty"`

	// An operating system package containing the vulnerability.
	Package       *string      `json:"package,omitempty"`
	PreferredCvss *CVSSDetails `json:"preferred_cvss,omitempty"`

	// A standard scale for measuring the severity of a vulnerability.
	//
	// * `Unknown` - either a security problem that has not been assigned to a priority yet or a priority that the
	//   scanner did not recognize.
	// * `Negligible` - technically a security problem, but is only theoretical in nature, requires a very special
	//   situation, has almost no install base, or does no real damage.
	// * `Low` - a security problem, but is hard to exploit due to environment, requires a user-assisted attack,
	//   a small install base, or does very little damage.
	// * `Medium` - a real security problem, and is exploitable for many people. Includes network daemon denial of
	//   service attacks, cross-site scripting, and gaining user privileges.
	// * `High` - a real problem, exploitable for many people in a default installation. Includes serious remote denial
	//   of service, local root privilege escalations, or data loss.
	// * `Critical` - a world-burning problem, exploitable for nearly all people in a default installation. Includes
	//   remote root privilege escalations, or massive data loss.
	Severity         *Severity                           `json:"severity,omitempty"`
	VendorAttributes *VulnerabilityItem_VendorAttributes `json:"vendor_attributes,omitempty"`

	// The version of the package containing the vulnerability.
	Version *string `json:"version,omitempty"`
}

// VulnerabilityItem_VendorAttributes defines model for VulnerabilityItem.VendorAttributes.
type VulnerabilityItem_VendorAttributes struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetScanReportParams defines parameters for GetScanReport.
type GetScanReportParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// Getter for additional properties for ScannerProperties. Returns the specified
// element and whether it was found
func (a ScannerProperties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScannerProperties
func (a *ScannerProperties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScannerProperties to handle AdditionalProperties
func (a *ScannerProperties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScannerProperties to handle AdditionalProperties
func (a ScannerProperties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for VulnerabilityItem_VendorAttributes. Returns the specified
// element and whether it was found
func (a VulnerabilityItem_VendorAttributes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for VulnerabilityItem_VendorAttributes
func (a *VulnerabilityItem_VendorAttributes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for VulnerabilityItem_VendorAttributes to handle AdditionalProperties
func (a *VulnerabilityItem_VendorAttributes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for VulnerabilityItem_VendorAttributes to handle AdditionalProperties
func (a VulnerabilityItem_VendorAttributes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get scanner metadata
	// (GET /metadata)
	GetMetadata(ctx echo.Context) error
	// Accept artifact scanning request
	// (POST /scan)
	AcceptScanRequest(ctx echo.Context) error
	// Get scan report
	// (GET /scan/{scan_request_id}/report)
	GetScanReport(ctx echo.Context, scanRequestId ScanRequestId, params GetScanReportParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMetadata(ctx)
	return err
}

// AcceptScanRequest converts echo context to params.
func (w *ServerInterfaceWrapper) AcceptScanRequest(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AcceptScanRequest(ctx)
	return err
}

// GetScanReport converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanReport(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scan_request_id" -------------
	var scanRequestId ScanRequestId

	err = runtime.BindStyledParameterWithLocation("simple", false, "scan_request_id", runtime.ParamLocationPath, ctx.Param("scan_request_id"), &scanRequestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scan_request_id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanReportParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept: %s", err))
		}

		params.Accept = &Accept
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScanReport(ctx, scanRequestId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/metadata", wrapper.GetMetadata)
	router.POST(baseURL+"/scan", wrapper.AcceptScanRequest)
	router.GET(baseURL+"/scan/:scan_request_id/report", wrapper.GetScanReport)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}
